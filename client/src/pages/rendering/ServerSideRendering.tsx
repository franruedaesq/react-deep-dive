import CodeExample from '@/components/CodeExample';

export default function ServerSideRendering() {
  return (
    <div className="content-page">
      <div className="container">
        <div className="page-header">
          <h1 className="page-title">Server Side Rendering (SSR)</h1>
          <p className="page-subtitle">
            Rendering React components on the server and hydrating them in the browser
          </p>
        </div>

        <div className="section">
          <h2 className="section-title">What is Server Side Rendering?</h2>
          <p className="content-text">
            Server Side Rendering (SSR) is an approach where React components are rendered on the server to generate HTML, 
            which is then sent to the browser. The browser receives fully rendered HTML and displays it immediately, then 
            downloads and executes JavaScript to make the page interactive through a process called hydration.
          </p>
          <p className="content-text">
            SSR combines the best of both worlds: fast initial page loads with SEO-friendly HTML, plus the rich interactivity 
            of client-side React. This approach powers many modern web frameworks like Next.js.
          </p>
        </div>

        <div className="section">
          <h2 className="section-title">The SSR Architecture</h2>
          <p className="content-text">
            SSR involves two distinct phases: the server rendering phase and the client hydration phase. Understanding both is 
            crucial for building performant SSR applications.
          </p>

          <CodeExample
            title="Server Rendering with renderToString()"
            language="javascript"
            code={`import { renderToString } from 'react-dom/server';
import express from 'express';
import App from './App';

const app = express();

app.get('/', (req, res) => {
  // Render the App component to an HTML string
  const html = renderToString(<App />);
  
  // Send the HTML to the browser
  res.send(\`
    <!DOCTYPE html>
    <html>
      <head>
        <title>My App</title>
      </head>
      <body>
        <div id="root">\${html}</div>
        <script src="/main.js"></script>
      </body>
    </html>
  \`);
});

app.listen(3000);`}
            description="Basic server-side rendering using renderToString()"
          />
        </div>

        <div className="section">
          <h2 className="section-title">Understanding renderToString()</h2>
          <p className="content-text">
            The renderToString() function is the fundamental API for server-side rendering. It takes a React component and 
            synchronously renders it to an HTML string. This string is then embedded in the HTML response sent to the browser.
          </p>

          <div className="highlight-box">
            <p>
              <strong>Important:</strong> renderToString() is synchronous and doesn't support Suspense or streaming. For modern 
              SSR with better performance, use renderToPipeableStream() instead.
            </p>
          </div>

          <CodeExample
            title="renderToString() API"
            language="typescript"
            code={`// Synchronously render a React tree to an HTML string
const html = renderToString(reactNode, options?);

// Parameters
interface RenderOptions {
  // A string prefix for IDs generated by useId()
  identifierPrefix?: string;
}

// Returns
// An HTML string representing the rendered component tree`}
            description="The renderToString() function signature and parameters"
          />
        </div>

        <div className="section">
          <h2 className="section-title">The Hydration Process</h2>
          <p className="content-text">
            Hydration is the process of attaching React to server-rendered HTML. The browser receives fully rendered HTML from 
            the server, displays it immediately, then downloads the JavaScript bundle. React then "hydrates" the HTML by attaching 
            event listeners and initializing state, making the page interactive.
          </p>

          <CodeExample
            title="Client-Side Hydration with hydrateRoot()"
            language="javascript"
            code={`import { hydrateRoot } from 'react-dom/client';
import App from './App';

// Hydrate the server-rendered HTML
const root = hydrateRoot(
  document.getElementById('root'),
  <App />
);

// React will:
// 1. Compare the rendered output with the server HTML
// 2. Attach event listeners to existing DOM elements
// 3. Initialize state and effects
// 4. Make the page interactive`}
            description="Using hydrateRoot() to hydrate server-rendered HTML"
          />
        </div>

        <div className="section">
          <h2 className="section-title">The Complete SSR Flow</h2>
          <p className="content-text">
            Let's trace through the complete SSR flow from initial request to fully interactive page:
          </p>

          <CodeExample
            title="Complete SSR Example"
            language="javascript"
            code={`// ===== SERVER SIDE =====
import { renderToString } from 'react-dom/server';
import express from 'express';
import App from './App';

const app = express();

app.get('/', (req, res) => {
  // Step 1: Render component to HTML string
  const html = renderToString(<App />);
  
  // Step 2: Send HTML to browser
  res.send(\`
    <!DOCTYPE html>
    <html>
      <head><title>My App</title></head>
      <body>
        <div id="root">\${html}</div>
        <script src="/main.js"></script>
      </body>
    </html>
  \`);
});

// ===== CLIENT SIDE =====
// main.js (downloaded by browser)
import { hydrateRoot } from 'react-dom/client';
import App from './App';

// Step 3: Browser receives HTML and displays it
// Step 4: Browser downloads main.js
// Step 5: Hydrate the server-rendered HTML
hydrateRoot(document.getElementById('root'), <App />);

// Step 6: Page becomes interactive`}
            description="The complete SSR flow from server to client"
          />
        </div>

        <div className="section">
          <h2 className="section-title">Streaming SSR with renderToPipeableStream()</h2>
          <p className="content-text">
            For better performance, modern SSR uses streaming. Instead of waiting for the entire component tree to render, 
            renderToPipeableStream() streams HTML chunks to the browser as they become available. This allows the browser to 
            start rendering content while the server is still generating HTML.
          </p>

          <CodeExample
            title="Streaming SSR with renderToPipeableStream()"
            language="javascript"
            code={`import { renderToPipeableStream } from 'react-dom/server';
import express from 'express';
import App from './App';

const app = express();

app.get('/', (req, res) => {
  const { pipe } = renderToPipeableStream(<App />, {
    bootstrapScripts: ['/main.js'],
    onShellReady() {
      // Shell is ready, start streaming
      res.setHeader('content-type', 'text/html');
      pipe(res);
    },
    onShellError(error) {
      // Error rendering shell, send error page
      res.statusCode = 500;
      res.send('<h1>Server Error</h1>');
    },
  });
});

app.listen(3000);`}
            description="Streaming SSR for better performance and progressive content delivery"
          />

          <div className="highlight-box">
            <p>
              <strong>Key Benefit:</strong> With streaming, users see content progressively. The HTML shell renders first, 
              allowing the browser to start rendering while the server continues generating content for Suspense boundaries.
            </p>
          </div>
        </div>

        <div className="section">
          <h2 className="section-title">Advantages of Server Side Rendering</h2>
          <p className="content-text">
            SSR offers significant advantages for many types of applications:
          </p>

          <div className="space-y-3 mb-6">
            <div className="p-4 rounded-lg bg-slate-50 dark:bg-slate-900 border border-slate-200 dark:border-slate-700">
              <h3 className="font-semibold text-slate-900 dark:text-slate-100 mb-2">Fast Initial Page Load</h3>
              <p className="text-slate-700 dark:text-slate-300 text-sm">
                Users receive fully rendered HTML immediately, enabling faster First Contentful Paint (FCP) and Largest 
                Contentful Paint (LCP) metrics. The page is visible before JavaScript loads.
              </p>
            </div>

            <div className="p-4 rounded-lg bg-slate-50 dark:bg-slate-900 border border-slate-200 dark:border-slate-700">
              <h3 className="font-semibold text-slate-900 dark:text-slate-100 mb-2">Excellent SEO</h3>
              <p className="text-slate-700 dark:text-slate-300 text-sm">
                Search engines receive fully rendered HTML, making content immediately indexable. Meta tags, structured data, 
                and content are all present in the initial HTML.
              </p>
            </div>

            <div className="p-4 rounded-lg bg-slate-50 dark:bg-slate-900 border border-slate-200 dark:border-slate-700">
              <h3 className="font-semibold text-slate-900 dark:text-slate-100 mb-2">Progressive Enhancement</h3>
              <p className="text-slate-700 dark:text-slate-300 text-sm">
                The page works without JavaScript. Users see content immediately, and interactivity is added progressively 
                through hydration, providing a graceful degradation experience.
              </p>
            </div>

            <div className="p-4 rounded-lg bg-slate-50 dark:bg-slate-900 border border-slate-200 dark:border-slate-700">
              <h3 className="font-semibold text-slate-900 dark:text-slate-100 mb-2">Rich Interactivity</h3>
              <p className="text-slate-700 dark:text-slate-300 text-sm">
                After hydration, the application provides the same rich, interactive experience as a full CSR application, 
                with instant state updates and smooth animations.
              </p>
            </div>
          </div>
        </div>

        <div className="section">
          <h2 className="section-title">Challenges and Trade-offs</h2>
          <p className="content-text">
            SSR introduces complexity and challenges that must be carefully managed:
          </p>

          <div className="space-y-3 mb-6">
            <div className="p-4 rounded-lg bg-amber-50 dark:bg-amber-950 border border-amber-200 dark:border-amber-800">
              <h3 className="font-semibold text-amber-900 dark:text-amber-100 mb-2">Hydration Mismatches</h3>
              <p className="text-amber-800 dark:text-amber-200 text-sm">
                If server and client render different content, React will warn about mismatches. This can cause event handlers 
                to attach to wrong elements, breaking interactivity. Common causes include conditional rendering based on 
                typeof window or random data.
              </p>
            </div>

            <div className="p-4 rounded-lg bg-amber-50 dark:bg-amber-950 border border-amber-200 dark:border-amber-800">
              <h3 className="font-semibold text-amber-900 dark:text-amber-100 mb-2">Increased Server Load</h3>
              <p className="text-amber-800 dark:text-amber-200 text-sm">
                The server must render components for every request, consuming CPU and memory. This can become a bottleneck 
                under high traffic, requiring careful optimization and caching strategies.
              </p>
            </div>

            <div className="p-4 rounded-lg bg-amber-50 dark:bg-amber-950 border border-amber-200 dark:border-amber-800">
              <h3 className="font-semibold text-amber-900 dark:text-amber-100 mb-2">Complex Architecture</h3>
              <p className="text-amber-800 dark:text-amber-200 text-sm">
                SSR requires running Node.js on the server and coordinating between server and client code. This adds 
                complexity to deployment, debugging, and maintenance compared to simple static hosting.
              </p>
            </div>

            <div className="p-4 rounded-lg bg-amber-50 dark:bg-amber-950 border border-amber-200 dark:border-amber-800">
              <h3 className="font-semibold text-amber-900 dark:text-amber-100 mb-2">Hydration Delay</h3>
              <p className="text-amber-800 dark:text-amber-200 text-sm">
                While the page appears loaded, it's not interactive until hydration completes. Users may click buttons or 
                interact with the page before it's ready, leading to poor perceived performance.
              </p>
            </div>
          </div>
        </div>

        <div className="section">
          <h2 className="section-title">Avoiding Hydration Mismatches</h2>
          <p className="content-text">
            Hydration mismatches are the most common SSR issue. Here are strategies to prevent them:
          </p>

          <CodeExample
            title="Common Hydration Mismatch Patterns"
            language="javascript"
            code={`// ❌ WRONG: Conditional rendering based on typeof window
function Component() {
  if (typeof window !== 'undefined') {
    return <div>Client only</div>;
  }
  return <div>Server or client</div>;
}

// ✅ CORRECT: Use useEffect for client-only logic
function Component() {
  const [isClient, setIsClient] = useState(false);
  
  useEffect(() => {
    setIsClient(true);
  }, []);
  
  return <div>{isClient ? 'Client only' : 'Server or client'}</div>;
}

// ❌ WRONG: Random data
function Component() {
  return <div>{Math.random()}</div>;
}

// ✅ CORRECT: Use consistent data
function Component() {
  const [id] = useState(() => Math.random());
  return <div>{id}</div>;
}`}
            description="Common hydration mismatch patterns and how to fix them"
          />
        </div>

        <div className="section">
          <h2 className="section-title">When to Use Server Side Rendering</h2>
          <p className="content-text">
            SSR is ideal for applications where initial load performance and SEO are critical:
          </p>

          <ul className="space-y-2 mb-6 list-disc list-inside text-slate-700 dark:text-slate-300">
            <li><strong>Public-facing websites:</strong> Blogs, marketing sites, e-commerce platforms</li>
            <li><strong>Content-heavy applications:</strong> News sites, documentation, social media</li>
            <li><strong>SEO-critical pages:</strong> Any page that needs to rank in search results</li>
            <li><strong>Performance-critical applications:</strong> Mobile-first applications, slow network scenarios</li>
            <li><strong>Hybrid applications:</strong> Combining SSR for initial load with CSR for interactivity</li>
          </ul>
        </div>

        <div className="section">
          <h2 className="section-title">Summary</h2>
          <p className="content-text">
            Server Side Rendering is a powerful approach that combines fast initial page loads with excellent SEO and rich 
            interactivity. By rendering components on the server and hydrating them in the browser, SSR provides the best of 
            both worlds.
          </p>
          <p className="content-text">
            However, SSR introduces complexity around hydration mismatches and server load. Modern frameworks like Next.js 
            abstract away much of this complexity, making SSR accessible to most developers. For best results, combine SSR 
            with caching strategies and consider Static Site Generation for content that doesn't change frequently.
          </p>
        </div>
      </div>
    </div>
  );
}
